@inherits RazorBlade.PlainTextTemplate<RSCG_CompositeProvider.DataFromExposeInterface>
@{
    string nameClass = Model.Name.StartsWith("I") ? Model.Name.Substring(1) : Model.Name;      
    nameClass += "_CP";
}
// <auto-generated>
    //     This code was generated by a tool :@Generated.RSCG_CompositeProvider.TheAssemblyInfo.AssemblyName
    //     Runtime Version: @Generated.RSCG_CompositeProvider.TheAssemblyInfo.GeneratedNameNice
    //     DateOfTool : @Generated.RSCG_CompositeProvider.TheAssemblyInfo.DateGeneratedUTC.ToString("yyyy-MM-dd HH:mm:ss")
    //     Changes to this file may cause incorrect behavior and will be lost if
    //     the code is regenerated.
    //</auto-generated>
//------------------------------------------------------------------------------
/// <summary>
    /// This static partial class is a composite provider of @Model.Name objects. 
    ///</summary>

#nullable enable
#pragma warning disable CS8603
#pragma warning disable CS8625
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[global::System.CodeDom.Compiler.GeneratedCode("GeneratorName","@Generated.RSCG_CompositeProvider.TheAssemblyInfo.DateGeneratedUTC.ToString("yyyy.1MMdd.1HHmm.1ss")")]
@Model.DebuggerDisplay()
public partial class @(nameClass) : @Model.FullName
{
public int? lastUsedInterface ;

private @(Model.FullName + "[]") values;
public @(nameClass)(params @(Model.FullName+"[]") values){
this.values=values;
}
public int Count{
get{
return values.Length;
}
}
public @Model.FullName Get(int nr){
    return values[nr];
}



@foreach (var prop in Model.props)
{
    <text>
        public @prop.Type @prop.Name { get
        {
        lastUsedInterface = null;
        foreach(var item in values){
        lastUsedInterface =(lastUsedInterface ??-1)+1;
        if(item == null)continue;
        try{
        return item.@prop.Name;
        }
        catch(Exception ){
        //try with the next one
        }
        }
        throw new System.Collections.Generic.KeyNotFoundException();
        }
        set
        {
        foreach(var item in values){
        if(item == null)continue;
        try{
        item.@prop.Name = value;
        }
        catch(Exception ){
        //try with the next one
        }
        }
        }

        } 
    </text>
}
@foreach (var func in Model.functions)
{
    string ret = Model.DefaultValueReturnFunc(func);
    bool isAsyncEnumberable = Model.IsAsyncEnumerable(func);
    if (isAsyncEnumberable)
    {
        <text>
            public virtual @Model.AsyncMethod(func) @func.ReturnType @Model.DisplayFunc(func) {
            lastUsedInterface =null;
            foreach(var item in values){
            lastUsedInterface =(lastUsedInterface ??-1)+1;
                if(item == null)continue;
            
                bool calledSuccess = false;
                @func.ReturnType? enumerable = null;
                try{
                    enumerable=  item.@(Model.CallFunc(func)) ;
                }
                catch(Exception){};
                if( enumerable==null)continue;
                await using var enumerator = enumerable.GetAsyncEnumerator();
                for (var more = true; more;)
                {
                    // Catch exceptions only on executing/resuming the iterator function
                    try
                    {
                        more = await enumerator.MoveNextAsync();
                        calledSuccess=true;
                    }
                    catch (Exception)
                    {
                        //already give some data,so no try with next
                        if(calledSuccess)
                            throw;
                        //no data yet, try next one
                            more=false;
                            break;
                    }
                    if(more){
                        yield return enumerator.Current;
                    }
                                            

                }
                if(calledSuccess) yield break;
            }
            throw new System.Collections.Generic.KeyNotFoundException();
            }
        </text>
    }
    else{
        <text>
            public virtual @Model.AsyncMethod(func) @func.ReturnType @Model.DisplayFunc(func) {
                lastUsedInterface =null;
                foreach(var item in values){
                    lastUsedInterface =(lastUsedInterface ??-1)+1;
                    if(item == null)continue;
                    try{
                        var data=  @Model.AwaitMethod(func) item.@(Model.CallFunc(func)) ;
                        return data;
                    }
                    catch(Exception ){
                        //try with the next one
                    }
                }
                throw new System.Collections.Generic.KeyNotFoundException();
            }
        </text>
    }
}

}